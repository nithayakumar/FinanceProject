/**
 * Property Calculations
 */

/**
 * Calculate implied remaining term from mortgage balance and payment
 * Uses standard amortization formula: N = -log(1 - (r*P)/A) / log(1+r)
 * where r = monthly rate, P = principal, A = monthly payment
 */
export function calculateRemainingTerm(principal, monthlyPayment, interestRate = 3.5) {
    if (!principal || !monthlyPayment || monthlyPayment <= 0 || principal <= 0) return null

    // If we don't know the exact rate on existing loan, we assume a standard one or need input
    // Since "Mortgage Rate" isn't an input for "Own" (per user spec), we might need to estimate or ask for it.
    // User spec: "Term remaining should be years and months autogenerated by mortgage remaining and mortgage payments."
    // Without rate, we can't solve exact N. But typical mortgages are 3-7%.
    // However, often "Own" inputs usually include rate. 
    // User spec for "Own": “Home Value”, “Growth Rate”, “Mortgage Remaining”, “Monthly Mortgage Payments”, “Term Remaining” (autogen).
    // It is mathematically impossible to calculate Term exactly without the Interest Rate.
    // I will assume a default effective rate if not provided, or better, calculate a "Payoff Date" based on 0% vs inferred?
    // Actually, usually users know rate. But if I can't add input, I'll derive 'Simple Payoff' (Balance / Payment) which is the absolute minimum time (0% interest).
    // Realistically, I should probably expose Rate for "Own" OR assume a standard legacy rate (e.g. 3.0% - 4.0%).
    // Let's use a heuristic: 
    // If (Balance / Payment) < some small number, use 0 int.
    // Otherwise, use 3.5% as a conservative estimate for existing loans?
    // Let's stick to simple payoff for now if Rate isn't in spec, BUT actually the user didn't explicitly forbid 'Rate' for 'Own', just listed specific fields.
    // I'll add 'impliedRate' logic or just use a default.

    const r = (3.5 / 100) / 12 // Assume 3.5% for existing loans as a fallback

    // If payment is less than interest, never pays off
    if (monthlyPayment <= principal * r) return { years: 99, months: 0, infinite: true }

    const n = -Math.log(1 - (r * principal) / monthlyPayment) / Math.log(1 + r)

    if (!isFinite(n)) return { years: 0, months: 0, valid: false }

    const years = Math.floor(n / 12)
    const months = Math.ceil(n % 12)

    return { years, months, valid: true }
}

/**
 * Calculate Monthly Payment for Buying scenario
 * P = L[c(1 + c)^n]/[(1 + c)^n - 1]
 */
export function calculateMonthlyPayment(loanAmount, ratePercent, termYears) {
    if (!loanAmount || !termYears) return 0

    const r = (ratePercent / 100) / 12
    const n = termYears * 12

    if (r === 0) return loanAmount / n

    return loanAmount * (r * Math.pow(1 + r, n)) / (Math.pow(1 + r, n) - 1)
}


/**
 * Generate yearly projections for Property
 */
export function calculatePropertyProjections(data, profile) {
    if (data.mode === 'none') return null

    // Determine years to project: Max(30, Years to Retirement, Mortgage Term + Purchase Delay)
    const currentAge = Number(profile.age) || 30
    const retirementAge = Number(profile.retirementAge) || 60
    const yearsToRetirement = Math.max(0, retirementAge - currentAge)

    // Calculate minimum years needed for mortgage
    let minMortgageYears = 30
    if (data.mode === 'buy') {
        const purchaseDelay = Number(data.details?.purchaseYear || 1) - 1
        const term = Number(data.details?.term || 30)
        minMortgageYears = purchaseDelay + term
    } else if (data.mode === 'own') {
        // For 'own', we might want to capture remaining term if known, but 30 is a safe floor
        // We could calc remaining term, but usually 30 covers it.
        // Let's stick to the max of components.
    }

    const yearsToProject = Math.max(30, yearsToRetirement, minMortgageYears + 2) // +2 buffer

    const currentYear = new Date().getFullYear()
    // Ensure we parse profile.inflationRate correctly. If it's undefined/null, use 2.7. 
    // If it is 0, we should use 0 (so strictly check null/undefined).
    const rawInflation = profile.inflationRate !== undefined && profile.inflationRate !== null ? profile.inflationRate : 2.7
    const inflationRate = Number(rawInflation) / 100

    const projections = []

    const { details } = data
    let homeValue = 0
    let mortgageBalance = 0
    let monthlyPayment = 0
    let interestRate = 0

    // Initialize baseline
    if (data.mode === 'own') {
        homeValue = Number(details.homeValue) || 0
        mortgageBalance = Number(details.mortgageRemaining) || 0
        monthlyPayment = Number(details.monthlyPayment) || 0
        // If we can't derive rate, we assume a standard or fallback.
        // However, if we know balance and payment, we can guess interest or just amortization.
        // For projection purprose, let's assume a rate if not provided in 'Own' Details?
        // Actually, 'Own' schema doesn't have rate.
        // So we iterate: Interest = Balance * r. Principal = Payment - Interest.
        // We need 'r'. Let's default to 3.5% if we can't solve it, or just use linear paydown if rate is unknown?
        // Linear is risky. Let's stick to 3.5% default for "Own" mode projections.
        interestRate = 3.5 / 100
    } else if (data.mode === 'buy') {
        const price = Number(details.homePrice) || 0
        let down = Number(details.downPayment) || 0
        if (details.downPaymentType === 'percent') {
            down = price * (down / 100)
        }

        // Initial State (Before Purchase)
        homeValue = 0
        mortgageBalance = 0
        interestRate = (Number(details.mortgageRate) || 0) / 100

        // Recalculate monthly payment to be sure it matches inputs
        const loanAmount = Math.max(0, price - down)
        const term = Number(details.term) || 30
        monthlyPayment = calculateMonthlyPayment(loanAmount, interestRate * 100, term)
    }

    const growthRate = (Number(details.growthRate) || 0) / 100
    const monthlyRate = interestRate / 12

    // Purchase timing for 'Buy' mode
    // Allow negative years (e.g. -5 means 5 years ago)
    const purchaseYearInput = Number(details.purchaseYear) || 1

    // We start the projection either at the purchase year (history) or Year 1 (now)
    // If purchase year is in the future (>1), we start at 1.
    // If purchase year is in the past (<1), we start at that past year.
    const startYearLoop = Math.min(1, purchaseYearInput)

    // Absolute Year Logic:
    // User Input "1" = Current Year (e.g. 2024)
    // User Input "0" = Last Year (e.g. 2023)
    // User Input "-5" = 6 Years Ago? Or 5 years before year 1?
    // Let's assume intuitive: 1 is relative 0. 
    // Actual Year = currentYear + (yearIndex - 1)

    for (let i = startYearLoop; i < yearsToProject; i++) {
        // i is the relative year index. 
        // i=1 => Current Year. i=0 => Last Year. i=-5 => 6 Years Ago.
        const year = currentYear + (i - 1)

        let yearEquity = 0
        let yearDebt = 0
        let yearInterest = 0
        let yearPrincipal = 0

        // Logic Split
        if (data.mode === 'own') {
            // Simple amortization
            for (let m = 0; m < 12; m++) {
                if (mortgageBalance > 0) {
                    const interest = mortgageBalance * monthlyRate
                    const principal = Math.min(monthlyPayment - interest, mortgageBalance)
                    yearInterest += interest
                    yearPrincipal += principal
                    mortgageBalance -= principal
                }
            }
            homeValue = homeValue * (1 + growthRate)
            yearEquity = homeValue - mortgageBalance
            yearDebt = mortgageBalance

        } else if (data.mode === 'buy') {
            // Buy Logic
            // purchaseYearInput is relative (e.g. 1 or -5)
            // If i < purchaseYearInput => Before purchase

            if (i < purchaseYearInput) {
                // Before purchase
                yearEquity = 0
                yearDebt = 0
            } else if (i === purchaseYearInput) {
                // Purchase Year
                const basePrice = Number(details.homePrice) || 0

                // Appreciate/Deflate price from Year 1 (Base) to Purchase Year (i)
                // If i=1 (Now), price = basePrice
                // If i=-5, price = basePV * (1+g)^-6? 
                // i starts at 1 for "Now". Distance is (i - 1).
                // Example: Year 1: dist=0. Price=Base.
                // Year -5: dist=-6. Price=Base * (1+g)^-6.

                const yearsFromBase = i - 1
                const purchasePrice = basePrice * Math.pow(1 + growthRate, yearsFromBase)

                // Re-calc down/loan
                let down = Number(details.downPayment) || 0
                if (details.downPaymentType === 'percent') {
                    // Check if downPayment is applied to purchase price or base price?
                    // Standard: Down payment % of Purchase Price.
                    down = purchasePrice * (down / 100)
                }

                // Initialize
                homeValue = purchasePrice
                mortgageBalance = Math.max(0, purchasePrice - down)

                // Recalculate monthly payment based on LOAN amount at purchase
                // We previously calc'd standard payment based on PRESENT numbers in initialization.
                // But for historical, the loan amount was different.
                // However, simple calculator often assumes "Payment is fixed".
                // If I simulate "Buy 5 years ago", my payment should be determined by that loan amount.
                // So we must re-calc payment here if it's the purchase year.
                const term = Number(details.term) || 30
                monthlyPayment = calculateMonthlyPayment(mortgageBalance, interestRate * 100, term)

                // Amortize for remaining months of this year? 
                // Let's assume full year for simplicity of annual chart
                for (let m = 0; m < 12; m++) {
                    if (mortgageBalance > 0) {
                        const interest = mortgageBalance * monthlyRate
                        const principal = Math.min(monthlyPayment - interest, mortgageBalance)
                        yearInterest += interest
                        yearPrincipal += principal
                        mortgageBalance -= principal
                    }
                }
                // Growth at end of year
                homeValue = homeValue * (1 + growthRate)
                yearEquity = homeValue - mortgageBalance
                yearDebt = mortgageBalance

            } else {
                // Post-purchase years
                for (let m = 0; m < 12; m++) {
                    if (mortgageBalance > 0) {
                        const interest = mortgageBalance * monthlyRate
                        const principal = Math.min(monthlyPayment - interest, mortgageBalance)
                        yearInterest += interest
                        yearPrincipal += principal
                        mortgageBalance -= principal
                    }
                }
                homeValue = homeValue * (1 + growthRate)
                yearEquity = homeValue - mortgageBalance
                yearDebt = mortgageBalance
            }
        }

        // Calculate Present Value (Deflate by inflation)
        // Deflate by i (years from now). 
        // If i=1 (Now), deflation factor ~ 1? Or end of year 1 is 1 year away?
        // Usually Year 1 means "Next 12 months". End of Year 1 is 1 year discounted.
        // If i=-5, we should INFLATE to get to Present Value?
        // PV = Nominal / (1+r)^t.
        // If t is negative (past), PV = Nominal * (1+r)^|t|. Which is correct, past dollars were worth more?
        // Wait, "Present Value" means "Value expressed in today's dollars".
        // $100 in year -5 (Past) -> today it's worth $100 * (1+inf)^5?
        // Actually, no. If I had $100 5 years ago, that bill is still $100.
        // PV usually acts as "Buying Power".
        // Let's stick to standard discounting: (1+r)^(i-1) might be safer?
        // Existing code: Math.pow(1 + inflationRate, i + 1). 
        // If i=1, power=2. That means Year 1 is discounted 2 years? That seems aggressive.
        // Usually Year 0 is Now (Power 0). Year 1 is Future (Power 1).
        // Since we output "year: i", let's use standard discount:

        // Define 'yearsFromNow' = i - 1?
        // If i=1 (Current Year), let's assume end-of-year, so 1 year discount.

        let yearsFromNow = i
        const deflator = Math.pow(1 + inflationRate, yearsFromNow)

        projections.push({
            year: i, // Relative Year (can be negative)
            absoluteYear: year,
            homeValue,
            equity: yearEquity,
            debt: yearDebt,
            totalPayment: monthlyPayment * 12,
            interestPaid: yearInterest,
            principalPaid: yearPrincipal,
            // PV Values
            homeValuePV: homeValue / deflator,
            equityPV: yearEquity / deflator,
            debtPV: yearDebt / deflator,
            totalPaymentPV: (monthlyPayment * 12) / deflator,
            interestPaidPV: yearInterest / deflator,
            principalPaidPV: yearPrincipal / deflator
        })
    }

    return projections
}
